// #pragma enable_d3d11_debug_symbols
#define PI 3.14159265358979323846

struct Particle
{
    float3 position;
	float3 velocity;
    float density;
};
RWStructuredBuffer<float3> particlePositions;
RWStructuredBuffer<Particle> particleRead;
RWStructuredBuffer<Particle> particleWrite;

////To be set from GPU controller
uint nParticles;
float time;
uint frame;
float viscosityCoefficient = 0.005;
float stiffnessCoefficient;
float tensionCoefficient;
float restDensity;
float3 gravityVector;
float timeStep = 0.0005;
uint particleMass= 1;

// float normA=1.0;
// float normB=0.0;

float boxSize;
float boxInfluence;

float WPolyh = 0;
float WSpikyh = 0;
float WVisch = 0;

///Sorting
uint cellsResolution;
uint cellsRadius;

//cell -> particle idx
RWStructuredBuffer<uint2> particlesCellsRead;
RWStructuredBuffer<uint2> particlesCellsWrite;

RWStructuredBuffer<uint> cellsStartIndices;

RWStructuredBuffer<uint> cellCounters;
RWStructuredBuffer<uint> cellToOffset; 
//////////////////////

//////Util/////
uint pcg(uint v) {
	uint state = v * 747796405u + 2891336453u;
	uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
	return (word >> 22u) ^ word;
  }
  
float pcgf(uint v) {
return float(pcg(v))/float(0xffffffffu);
}

uint2 GetCoordsFromPos(uint pId)
{
	Particle particle = particleRead[pId];

	float cellSize = boxSize/float(cellsResolution);
	uint xCoord = floor((particle.position.x + boxSize/2) / cellSize);
	uint yCoord = floor((particle.position.y + boxSize/2) / cellSize);

	return uint2(xCoord, yCoord);
}
/////////////

///////Kernels

float WPoly(float3 deltaPos, float h){
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefA = 4.0 / (PI*pow(h, 8.0));
		float v = h*h - dst*dst;
		return coefA * pow(v, 3.0);
	}
	return float(0.0);
}

float3 WPolyGradient(float3 deltaPos, float h)
{
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefB = 24.0 / (PI * pow(h, 8.0));
		return -coefB * deltaPos * pow((h*h - dst*dst), 2.0);
	}
	return float3(0.0, 0.0, 0.0);
}

float WPolyLaplace(float3 deltaPos, float h)
{
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefC = 24.0 / (PI * pow(h, 8.0));
		return -coefC * (h*h - dst*dst) * (3*h*h - 7*dst*dst);
	}
	return float(0.0);
}

float3 WSpikyGradient(float3 deltaPos, float h)
{
	float dst = max(length(deltaPos), 0.0001);
    if (dst > 0 && dst <= h)
	{
		float coefB = 30.0 / (PI * pow(h, 5.0));
		return (-coefB * deltaPos * pow((h - dst), 2.0)) / dst;
	}
	return float3(0.0, 0.0, 0.0);
}

float WViscLaplace(float3 deltaPos, float h)
{
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefC = 20.0 / (PI * pow(h, 5.0));
		return -coefC * (h - dst);
	}
	return float(0.0);
}

float3 WViscGradient(float3 deltaPos, float h)
{
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefB = 10.0 / (PI * pow(h, 2.0));
	        float term1 = (-3.0 * dst) / (2.0 * pow(h, 3.0));
	        float term2 = 2.0 / pow(h, 2.0);
	        float term3 = h / (2.0 * pow(dst, 3.0));
	        return -coefB * deltaPos * (term1 + term2 - term3);
	}
	return float3(0.0, 0.0, 0.0);
}
/////////////

///////Forces
float GetDensityAtParticle(uint3 id)
{
	uint currentParticleIdx = id.x;
	float density = 0;
	uint2 particleCellCoords = GetCoordsFromPos(currentParticleIdx);

	uint cellLeftStartIdx = max(0, int(particleCellCoords.x) - int(cellsRadius));
	uint cellRightEndIdx = min(int(cellsResolution)-1, int(particleCellCoords.x) + int(cellsRadius));

	uint cellTopStartIdx = max(0, int(particleCellCoords.y) - int(cellsRadius));
	uint cellBottomEndIdx = min(int(cellsResolution)-1, int(particleCellCoords.y) + int(cellsRadius));

	for(uint x = cellLeftStartIdx; x <= cellRightEndIdx; x++)
	{
		for(uint y = cellTopStartIdx; y <= cellBottomEndIdx; y++)
		{
			uint cellCoord = x + cellsResolution*y;
			uint bound = cellsStartIndices[cellCoord] + cellCounters[cellCoord];
			for(uint neighbour = cellsStartIndices[cellCoord]; neighbour < bound; neighbour++)
			{
				if(particlesCellsRead[neighbour].y == currentParticleIdx){continue;}

				density += WPoly(particleRead[currentParticleIdx].position - particleRead[particlesCellsRead[neighbour].y].position, WPolyh);
			}
		}
	}

	return density * particleMass;
}

float3 GetGravityAtParticle(uint3 id)
{
	return particleMass * gravityVector;
}

float3 GetTensionNorm(uint3 id, uint neighbour)
{
	uint currentParticleIdx = id.x;
	float3 normContribution = WPolyGradient(particleRead[currentParticleIdx].position - particleRead[particlesCellsRead[neighbour].y].position, WPolyh)/max(particleRead[particlesCellsRead[neighbour].y].density, 0.0001);
	return -normContribution;
}

float GetTensionLaplacian(uint3 id, uint neighbour)
{
	uint currentParticleIdx = id.x;
	float laplacianContribution = WPolyLaplace(particleRead[currentParticleIdx].position - particleRead[particlesCellsRead[neighbour].y].position, WPolyh)/max(particleRead[particlesCellsRead[neighbour].y].density, 0.0001);

	return laplacianContribution;
}

float3 GetTensionAtPoint(float3 norm, float laplacian)
{
	return -tensionCoefficient * laplacian * norm / max(length(norm), 0.0001);
}

float smoothstep(float x, float a, float b) {
    float frac = (x-a)/(b-a);
    float max = frac>0 ? frac : 0;
    float t = max<1 ? max : 1;
   
    return t*t*(3-2*t); 
}

// float3 GetBoxNormalForce(uint3 curPoint) {
// 	float _box_start = boxSize - boxInfluence;
//     float3 force;
//     float horizontal = smoothstep(abs(curPoint.x), _box_start, boxSize);
//     float vertical = smoothstep(abs(curPoint.y), _box_start, boxSize);
//     force.x = -curPoint.x * horizontal;
//     force.y = -curPoint.y * vertical;
// 	force.z = 0;
    
//     return force;
// }

// float3 GetAcelerationDueNormalAtParticle(uint3 id, float3 curAcceleration)
// {
// 	Particle curParticle = particleRead[id.x];
// 	float dx = boxSize/2 - abs(curParticle.position.x);
// 	float dy = boxSize/2 - abs(curParticle.position.y);

// 	float factorx = smoothstep(dx, normA, normB);
// 	float factory = smoothstep(dy, normA, normB);

// 	float coefx = sign(curParticle.position.x) == sign(curAcceleration.x)? 1 : 0;
// 	float coefy = sign(curParticle.position.y) == sign(curAcceleration.y)? 1 : 0;

// 	float3 newAcceleration = float3(curAcceleration.x - (curAcceleration.x+sign(curAcceleration.x)*abs(dx))*factorx * coefx,curAcceleration.y - (curAcceleration.y+sign(curAcceleration.y)*abs(dy))*factory * coefy, 0);
// 	return newAcceleration;
// }

float EquationOfState(float density, float restDensity)
{
	return stiffnessCoefficient * (density - restDensity);
}

float3 GetViscosityAtParticle(Particle currentParticle, uint currentParticleIdx, uint neighbour)
{
	Particle targetParticle = particleRead[particlesCellsRead[neighbour].y];
	float3 deltaPos = currentParticle.position - targetParticle.position;

	float weightV = WViscLaplace(deltaPos, WPolyh);
	float3 dir = deltaPos / max(length(deltaPos), 0.0001);
	float3 relativeVelocity = currentParticle.velocity - targetParticle.velocity;
	return viscosityCoefficient * dot(relativeVelocity, dir) * weightV * dir * particleMass;

	// float weightV = WViscLaplace(deltaPos, WPolyh);
	// float3 dir = deltaPos / max(length(deltaPos), 0.0001);
	// float3 relativeVelocity = currentParticle.velocity - targetParticle.velocity;
	// return -viscosityCoefficient * dot(relativeVelocity, dir) * weightV * WPolyGradient(deltaPos, WPolyh) * particleMass;;
}

float3 GetPressureAtParticle(Particle currentParticle, uint currentParticleIdx, uint neighbour)
{
	Particle targetParticle = particleRead[particlesCellsRead[neighbour].y];
	float3 deltaPos = currentParticle.position - targetParticle.position;

	float weightP = WPoly(deltaPos, WPolyh);
	
	float3 dir = deltaPos / max(length(deltaPos), 0.0001);
	float density = 0.5 * (currentParticle.density + targetParticle.density);
	float pressure = EquationOfState(density, restDensity);
	pressure *= weightP;

	return pressure * dir * particleMass;

	// Particle targetParticle = particleRead[particlesCellsRead[neighbour].y];
	// float3 deltaPos = currentParticle.position - targetParticle.position;

	// float weightP = WPoly(deltaPos, WPolyh);
	// float density = 0.5 * (currentParticle.density + targetParticle.density);
	// float pressure = EquationOfState(density, restDensity);
	// pressure *= weightP;

	// return pressure * deltaPos * particleMass;
}

//need to add gradient spline kernel 
float3 CalculateAcceleration(uint3 particleId)
{
	uint currentParticleIdx = particleId.x;

	float3 acceleration = float3(0,0,0);

	float3 newPressure = float3(0.0,0.0,0.0);
	float3 newViscosity = float3(0.0,0.0,0.0);
	float newLaplacian = 0;
	float3 newNorm = float3(0,0,0);

	Particle currentParticle = particleRead[currentParticleIdx];
	uint2 particleCellCoords = GetCoordsFromPos(currentParticleIdx);

	uint cellLeftStartIdx = max(0, int(particleCellCoords.x) - int(cellsRadius));
	uint cellRightEndIdx = min(int(cellsResolution)-1, int(particleCellCoords.x) + int(cellsRadius));

	uint cellTopStartIdx = max(0, int(particleCellCoords.y) - int(cellsRadius));
	uint cellBottomEndIdx = min(int(cellsResolution)-1, int(particleCellCoords.y) + int(cellsRadius));

	for(uint x = cellLeftStartIdx; x <= cellRightEndIdx; x++)
	{
		for(uint y = cellTopStartIdx; y <= cellBottomEndIdx; y++)
		{
			uint cellCoord = x + cellsResolution*y;
			uint bound = cellsStartIndices[cellCoord] + cellCounters[cellCoord];
			for(uint neighbour = cellsStartIndices[cellCoord]; neighbour < bound; neighbour++)
			{
				if(particlesCellsRead[neighbour].y == currentParticleIdx){continue;}
				newPressure += GetPressureAtParticle(currentParticle, currentParticleIdx, neighbour);
				newViscosity += GetViscosityAtParticle(currentParticle, currentParticleIdx, neighbour);
				newLaplacian += GetTensionLaplacian(particleId, neighbour);
				newNorm += GetTensionNorm(particleId, neighbour); 
			}
		}
	}

	newNorm *= particleMass;
	newLaplacian *= particleMass;

	// particlesCellsRead[currentParticleIdx] = particleCellCoords;

	// float3 newPressure = GetPressureAtParticle(currentParticle, currentParticleIdx);
	// float3 newViscosity = GetViscosityAtParticle(currentParticle, currentParticleIdx);
	float3 newGravity = GetGravityAtParticle(particleId);
	float3 newTension = GetTensionAtPoint(newNorm, newLaplacian);

	acceleration += (newTension + newGravity + newViscosity + newPressure)/particleMass;

	return acceleration;
}

#pragma kernel ParticleLoop 
[numthreads(64,1,1)]
void ParticleLoop(uint3 id : SV_DispatchThreadID)
{
	uint currentParticleIdx = id.x;
	if(currentParticleIdx >= nParticles){return;}

	Particle prevParticle = particleRead[currentParticleIdx];
	if(frame == 0)
	{
		prevParticle.velocity = float3(0.0,0.0,0.0);
		prevParticle.position = float3(pcgf(currentParticleIdx) * 120-60, pcgf(currentParticleIdx+7) * 30, 0.0);
		prevParticle.density = 1;

		particleRead[currentParticleIdx] = prevParticle;
	} else
	{
		float3 frameAcceleration = CalculateAcceleration(id);
		prevParticle.velocity += timeStep * frameAcceleration;
		prevParticle.position += prevParticle.velocity * timeStep;

		if(abs(prevParticle.position.x) > boxSize/2)
		{
			prevParticle.position.x = boxSize/2 * sign(prevParticle.position.x);
			prevParticle.velocity.x *= -1 * boxInfluence;
		}
		if(abs(prevParticle.position.y) > boxSize/2)
		{
			prevParticle.position.y = boxSize/2 * sign(prevParticle.position.y);
			prevParticle.velocity.y *= -1 * boxInfluence;
		}
	}

	particleWrite[currentParticleIdx] = prevParticle;
	particlePositions[currentParticleIdx] = prevParticle.position;

	float cellSize = boxSize/cellsResolution;

	uint xCoord = abs(floor((prevParticle.position.x + boxSize/2) / cellSize));
	uint yCoord = abs(floor((prevParticle.position.y + boxSize/2) / cellSize));

	uint newCellIdx = xCoord + cellsResolution*yCoord;

	particlesCellsWrite[currentParticleIdx] = uint2(newCellIdx, currentParticleIdx);
}

#pragma kernel ParticleDensity
[numthreads(64,1,1)]
void ParticleDensity(uint3 id : SV_DispatchThreadID)
{
	uint currentParticleIdx = id.x;
	if(currentParticleIdx >= nParticles){return;}

	Particle particle = particleRead[currentParticleIdx];

	float density = GetDensityAtParticle(id);

	particle.density = density;

	particleWrite[currentParticleIdx] = particle;
}

uint nParticlesPerThread;
//Count how many particles are in each cell
#pragma kernel CountCells
[numthreads(64,1,1)]
void CountCells(uint3 id : SV_DispatchThreadID)
{
	uint startIdx = id.x * nParticlesPerThread;
	uint endIdx = startIdx + nParticlesPerThread;

	for(uint i = startIdx; i < endIdx; i++)
	{
		uint cellIdx = particlesCellsRead[i].x;
		InterlockedAdd(cellCounters[cellIdx], 1);
	}
}

uint nCellsPerThread;
//Calculate prefix sums for individual cells
#pragma kernel CellPrefixSum
[numthreads(64,1,1)]
void CellPrefixSum(uint3 id : SV_DispatchThreadID)
{
	uint threadCountersStartIdx = id.x * nCellsPerThread;
	uint threadCountersEndIdx = threadCountersStartIdx + nCellsPerThread;
	uint nCells = cellsResolution*cellsResolution;

	for(uint i = threadCountersStartIdx; i < threadCountersEndIdx; i++)
	{
		uint cellCount = cellCounters[i];
		for(uint j = i+1; j < nCells; j++)
		{
			InterlockedAdd(cellToOffset[j], cellCount);
		}
	}
}

//Move cell-particle pairs to new sorted positions. No stability required
#pragma kernel SortMap
[numthreads(64,1,1)]
void SortMap(uint3 id : SV_DispatchThreadID)
{
	uint startIdx = id.x * nParticlesPerThread;
	uint endIdx = startIdx + nParticlesPerThread;

	for(uint i = startIdx; i < endIdx; i++)
	{
		uint cellIdx = particlesCellsRead[i].x;
		uint offset;
		InterlockedAdd(cellToOffset[cellIdx], 1, offset);

		particlesCellsWrite[offset] = particlesCellsRead[i];
	}
}

//Determine where each cell's pairs start in the output array
#pragma kernel AssignCellRegions
[numthreads(64,1,1)]
void AssignCellRegions(uint3 id : SV_DispatchThreadID)
{
	uint startIdx = id.x * nParticlesPerThread;
	uint endIdx = startIdx + nParticlesPerThread;

	uint prevCellIdx = startIdx == 0 ? cellsResolution*cellsResolution : particlesCellsWrite[startIdx-1].x;
	for(uint i = startIdx; i < endIdx; i++)
	{
		uint currentCellIdx = particlesCellsWrite[i].x;
		if(currentCellIdx != prevCellIdx)
		{
			cellsStartIndices[currentCellIdx] = i;
			prevCellIdx = currentCellIdx;
		}
	}
}

//clear counters
#pragma kernel ClearCounters
[numthreads(64,1,1)]
void ClearCounters(uint3 id : SV_DispatchThreadID)
{
	uint threadCountersStartIdx = id.x * nCellsPerThread;
	uint threadCountersEndIdx = threadCountersStartIdx + nCellsPerThread;

	for(uint i = threadCountersStartIdx; i < threadCountersEndIdx; i++)
	{
		cellCounters[i] = 0;
		cellToOffset[i] = 0;		
	}	
}
