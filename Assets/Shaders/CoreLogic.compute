#define PI 3.14159265358979323846

struct Particle
{
    float3 position;
	float3 velocity;
	float3 viscosity;
    float pressure;
    float density;
	float currentForce;
};
RWStructuredBuffer<float3> particlePositions;
RWStructuredBuffer<Particle> particleRead;
RWStructuredBuffer<Particle> particleWrite;

////To be set from GPU controller

uint nParticles;
float time;
uint frame;
float viscosityCoefficient;
float tensionCoefficient;
float3 gravityVector;
float timestep = 0.005;
float3 BoxSize;
float particleMass= 2.0;
float radius = 2;

float BOX_SCALE;
float BOX_INFLUENCE;

//////////////////////

//////Util/////
uint pcg(uint v) {
	uint state = v * 747796405u + 2891336453u;
	uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
	return (word >> 22u) ^ word;
  }
  
float pcgf(uint v) {
return float(pcg(v)) / float(0xffffffffu);
}
/////////////

///////Kernels
float WPolyh = 0;

float WPoly(float3 deltaPos, float h){
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefA = 4.0 / (PI*pow(h, 8.0));
		float v = h*h - dst*dst;
		return coefA * pow(v, 3.0);
	}
	return 0;
}

float3 WPolyGradient(float3 deltaPos, float h)
{
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefB = 24.0 / (PI * pow(h, 8.0));
		return -coefB * deltaPos * pow((h*h - dst*dst), 2.0);
	}
	return float3(0.0, 0.0, 0.0);
}

float WPolyLaplace(float3 deltaPos, float h)
{
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefC = 24.0 / (PI * pow(h, 8.0));
		return -coefC * (h*h - dst*dst) * (3*h*h - 7*dst*dst);
	}
	return 0;
}

float WSpikyh = 0;
float3 WSpikyGradient(float3 deltaPos, float h)
{
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefB = 30.0 / (PI * pow(h, 5.0));
		return (-coefB * deltaPos * pow((h - dst), 2.0)) / dst;
	}
	return float3(0.0, 0.0, 0.0);
}

float WVisch = 0;
float WViscLaplace(float3 deltaPos, float h)
{
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefC = 20.0 / (PI * pow(h, 5.0));
		return -coefC * (h - dst);
	}
	return 0;
}
float radius4 = 16;
float radius5 = 32;
float SpikyKernelFirstDerivative(float distance)
{
    float x = 1.0f - distance / radius;
    return -45.0f / ( PI * radius4 ) * x * x;
}
float SpikyKernelSecondDerivative(float distance)
{

    float x = 1.0f - distance / radius;
    return 90.f / ( PI * radius5 ) * x;
}


float3 SpikyKernelGradient(float distance, float3 directionFromCenter)
{
    return SpikyKernelFirstDerivative(distance) * directionFromCenter;
}
/////////////

///////Forces
float GetDensityAtParticle(uint3 id)
{
	uint currentParticleIdx = id.x;
	float density = 0;
	for(uint i = 0; i < nParticles; i++)
	{
		density += WPoly(particleRead[currentParticleIdx].position - particleRead[i].position, WPolyh);
	}
	return density*particleMass;
}

float3 GetGravityAtParticle(uint3 id)
{
	return particleRead[id.x].density * gravityVector;
}

float3 GetPressureAtParticle(uint3 id)
{
	uint currentParticleIdx = id.x;
	float3 newPressure = float3(0,0,0);
	for(uint i = 0; i < nParticles; i++)
	{
		float tempTerm = ((particleRead[currentParticleIdx].pressure + particleRead[i].pressure)*particleMass) /(2 * particleRead[i].density);
		float3 pressureContribution = WSpikyGradient(particleRead[currentParticleIdx].position - particleRead[i].position, WSpikyh) * tempTerm;

		newPressure += pressureContribution;
	}
	return -1 * newPressure;
}

float3 GetViscosityAtParticle(uint3 id)
{
	uint currentParticleIdx = id.x;
	float3 newViscosity = float3(0,0,0);

	for(uint i = 0; i < nParticles; i++)
	{
		float3 tempTerm = particleRead[i].viscosity - particleRead[currentParticleIdx].viscosity * (particleMass/particleRead[i].density);
		tempTerm *= WViscLaplace(particleRead[currentParticleIdx].position - particleRead[i].position, WVisch);
	}
	return viscosityCoefficient * newViscosity;
}

float3 GetTensionNorm(uint3 id)
{
	uint currentParticleIdx = id.x;
	float3 newNorm = float3(0,0,0);

	for(uint i = 0; i < nParticles; i++)
	{
		float3 normContribution = WPolyGradient(particleRead[currentParticleIdx].position - particleRead[i].position, WPolyh)/particleRead[i].density;
		newNorm += normContribution;
	}
	return -1 * newNorm * particleMass; //theoretically minus must be here
}

float GetTensionLaplacian(uint3 id)
{
	uint currentParticleIdx = id.x;
	float newLaplacian = 0;

	for(uint i = 0; i < nParticles; i++)
	{
		float laplacianContribution = WPolyLaplace(particleRead[currentParticleIdx].position - particleRead[i].position, WPolyh)/particleRead[i].density;
		newLaplacian += laplacianContribution;
	}
	return newLaplacian * particleMass;
}

float3 GetTensionAtPoint(uint3 id)
{
	float3 norm = GetTensionNorm(id);
	return -tensionCoefficient * GetTensionLaplacian(id) * norm / length(norm);
}

float smoothstep(float x, float a, float b) {
    float frac = (x-a)/(b-a);
    float max = frac>0 ? frac : 0;
    float t = max<1 ? max : 1;
   
    return t*t*(3-2*t); 
}

float3 boxNormalForce(float3 curPoint) {
	float _box_start = BOX_SCALE - BOX_INFLUENCE;
    float3 force;
    float horizontal = smoothstep(abs(curPoint.x), _box_start, BOX_SCALE);
    float vertical = smoothstep(abs(curPoint.y), _box_start, BOX_SCALE);
    force.x = -curPoint.x * horizontal;
    force.y = -curPoint.y * vertical;
    
    return force;
}
uint hash(uint x) {
    x += (x << 10u);
    x ^= (x >> 6u);
    x += (x << 3u);
    x ^= (x >> 11u);
    x += (x << 15u);
    return x;
}

float rand(uint seed) {
    return frac(sin(hash(seed)) * 43758.5453);
}

float viscosity = 200;
[numthreads(64,1,1)]
void ComputeForces (uint3 id: SV_DISPATCHTHREADID)
{
    float3 origin = particleRead[id.x].position;
    float density2 = particleRead[id.x].density * particleRead[id.x].density; 
    float3 pressure = float3(0,0,0);
    float3 visc = float3(0,0,0);
    float mass2 = particleMass * particleMass;

    for (int i = 0; i < nParticles; ++i) {
        
        if (origin.x == particleRead[i].position.x && origin.y == particleRead[i].position.y && origin.z == particleRead[i].position.z) {
            continue;
        }

        float dist = distance(particleRead[i].position, origin);
        if (dist < radius*2) {
            float3 pressureGradientDirection = normalize(particleRead[id.x].position-particleRead[i].position);
            pressure += mass2 * ( particleRead[id.x].pressure / density2 + particleRead[i].pressure / ( particleRead[i].density * particleRead[i].density ) ) * SpikyKernelGradient(dist, pressureGradientDirection);
            visc += viscosity * mass2 * ( particleRead[i].velocity - particleRead[id.x].velocity ) / particleRead[i].density * SpikyKernelSecondDerivative(dist);
        }
    }

    particleWrite[id.x].currentForce = float3(0,(-9.81 * particleMass), 0) - pressure + visc;

    // Handle Collision

    // float3 colDir = particleRead[id.x].position-spherePos;
    // if (length(colDir) < sphereRadius) {
    //     float mag = sphereRadius/length(colDir);
    //     particleRead[id.x].currentForce += colDir*300*mag;
    // }

    // + pressure + visc/_particles[id.x].density;
}
#pragma kernel ParticleLoop 
[numthreads(64,1,1)]
void ParticleLoop(uint3 id : SV_DispatchThreadID)
{
	Particle prevParticle = particleRead[id.x];
	Particle currentParticle = particleWrite[id.x];
	if(frame == 0)
	{
		prevParticle.pressure = 0;
		prevParticle.density = 0;
		prevParticle.currentForce = 0;
		float3 viscosity = 0;
		float2 seed = float2(id.x, frame);
		prevParticle.position = float3(pcgf(id.x), pcgf(id.x+1), 0.0);
		prevParticle.velocity = float3(rand(seed + 2.0), rand(seed + 3.0), rand(seed + 4.0)) * 2.0 - 1.0;
	}
	else
	{
		float3 force = 0;
		float3 vel = 0;
		for(uint i = 0; i < nParticles; i++)
		{
			Particle targetParticle = particleRead[i];
			if (targetParticle.position.x == particleRead[i].position.x && targetParticle.position.y == particleRead[i].position.y && targetParticle.position.z == particleRead[i].position.z) {
				continue;
			}
			ComputeForces(id);
			float3 deltaPos = prevParticle.position - targetParticle.position;
			float dst = length(deltaPos) + 0.0001;
			//compute gravitational force
			// force -= 0.00001*deltaPos / pow(dst, 3);
			vel += prevParticle.velocity + ((prevParticle.currentForce/particleMass) *0.005);
			// prevParticle.position += vel * 0.005;
			// prevParticle.velocity = vel;
		}
		prevParticle.position += vel * 0.005;
		prevParticle.velocity = vel;
	
		
		// prevParticle.velocity += force * 0.005;
		// prevParticle.position += prevParticle.velocity * 0.005;
	}

	
	particleWrite[id.x] = prevParticle;
    particlePositions[id.x] = prevParticle.position;
}

