#pragma enable_d3d11_debug_symbols
#define PI 3.14159265358979323846

struct Particle
{
    float3 position;
	float3 velocity;
    float density;
};
RWStructuredBuffer<float3> particlePositions;
RWStructuredBuffer<Particle> particleRead;
RWStructuredBuffer<Particle> particleWrite;

////To be set from GPU controller
uint nParticles;
float time;
uint frame;
float viscosityCoefficient = 0.005;
float stiffnessCoefficient;
float tensionCoefficient;
float restDensity;
float3 gravityVector;
float timeStep = 0.0005;
float particleMass= 1.0;

float BOX_SCALE;
float BOX_INFLUENCE;

float WPolyh = 0;
float WSpikyh = 0;
float WVisch = 0;

//////////////////////

//////Util/////
uint pcg(uint v) {
	uint state = v * 747796405u + 2891336453u;
	uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
	return (word >> 22u) ^ word;
  }
  
float pcgf(uint v) {
return float(pcg(v)) / float(0xffffffffu);
}
/////////////

///////Kernels

float WPoly(float3 deltaPos, float h){
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefA = 4.0 / (PI*pow(h, 8.0));
		float v = h*h - dst*dst;
		return coefA * pow(v, 3.0);
	}
	return 0;
}

float3 WPolyGradient(float3 deltaPos, float h)
{
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefB = 24.0 / (PI * pow(h, 8.0));
		return -coefB * deltaPos * pow((h*h - dst*dst), 2.0);
	}
	return float3(0.0, 0.0, 0.0);
}

float WPolyLaplace(float3 deltaPos, float h)
{
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefC = 24.0 / (PI * pow(h, 8.0));
		return -coefC * (h*h - dst*dst) * (3*h*h - 7*dst*dst);
	}
	return 0;
}

float3 WSpikyGradient(float3 deltaPos, float h)
{
	float dst = max(length(deltaPos), 0.0001);
    if (dst > 0 && dst <= h)
	{
		float coefB = 30.0 / (PI * pow(h, 5.0));
		return (-coefB * deltaPos * pow((h - dst), 2.0)) / dst;
	}
	return float3(0.0, 0.0, 0.0);
}

float WViscLaplace(float3 deltaPos, float h)
{
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefC = 20.0 / (PI * pow(h, 5.0));
		return -coefC * (h - dst);
	}
	return 0;
}
/////////////

///////Forces
float GetDensityAtParticle(uint3 id)
{
	uint currentParticleIdx = id.x;
	float density = 0;
	for(uint i = 0; i < nParticles; i++)
	{
		if(i == currentParticleIdx){continue;}
		density += WPoly(particleRead[currentParticleIdx].position - particleRead[i].position, WPolyh);
	}
	return density * particleMass;
}

float3 GetGravityAtParticle(uint3 id)
{
	return particleRead[id.x].density * gravityVector;
}

float3 GetTensionNorm(uint3 id)
{
	uint currentParticleIdx = id.x;
	float3 newNorm = float3(0,0,0);

	for(uint i = 0; i < nParticles; i++)
	{
		if(i == currentParticleIdx){continue;}

		float3 normContribution = WPolyGradient(particleRead[currentParticleIdx].position - particleRead[i].position, WPolyh)/max(particleRead[i].density, 0.0001);
		newNorm += normContribution;
	}
	return -1 * newNorm * particleMass;
}

float GetTensionLaplacian(uint3 id)
{
	uint currentParticleIdx = id.x;
	float newLaplacian = 0;

	for(uint i = 0; i < nParticles; i++)
	{
		if(i == currentParticleIdx){continue;}

		float laplacianContribution = WPolyLaplace(particleRead[currentParticleIdx].position - particleRead[i].position, WPolyh)/max(particleRead[i].density, 0.0001);
		newLaplacian += laplacianContribution;
	}
	return newLaplacian * particleMass;
}

float3 GetTensionAtPoint(uint3 id)
{
	float3 norm = GetTensionNorm(id);
	return -tensionCoefficient * GetTensionLaplacian(id) * norm / max(length(norm), 0.0001);
}

float smoothstep(float x, float a, float b) {
    float frac = (x-a)/(b-a);
    float max = frac>0 ? frac : 0;
    float t = max<1 ? max : 1;
   
    return t*t*(3-2*t); 
}

float3 GetBoxNormalForce(uint3 curPoint) {
	float _box_start = BOX_SCALE - BOX_INFLUENCE;
    float3 force;
    float horizontal = smoothstep(abs(curPoint.x), _box_start, BOX_SCALE);
    float vertical = smoothstep(abs(curPoint.y), _box_start, BOX_SCALE);
    force.x = -curPoint.x * horizontal;
    force.y = -curPoint.y * vertical;
	force.z = 0;
    
    return force;
}

float EquationOfState(float density, float restDensity)
{
	return stiffnessCoefficient * (density - restDensity);
}

//need to add gradient spline kernel 
float3 CalculateAcceleration(uint3 particleId)
{
	uint currentParticleIdx = particleId.x;
	float3 acceleration = float3(0,0,0);
	for(uint j = 0; j < nParticles; j++)
	{
		if(j == currentParticleIdx){continue;}
		float3 deltaPos = particleRead[currentParticleIdx].position - particleRead[j].position;

		//adding viscosity
		float weightV = WViscLaplace(deltaPos, WPolyh);
		float3 dir = deltaPos / max(length(deltaPos), 0.0001);
		float3 relativeVelocity = particleRead[currentParticleIdx].velocity - particleRead[j].velocity;
		acceleration -= viscosityCoefficient * dot(relativeVelocity, dir) * weightV * WPolyGradient(deltaPos, WPolyh) * particleMass;;

		//adding pressure
		float weightP = WPoly(deltaPos, WPolyh);
		float density = 0.5 * (particleRead[currentParticleIdx].density + particleRead[j].density);
		float pressure = EquationOfState(density, restDensity);
		pressure *= weightP;
		acceleration += pressure * deltaPos/particleMass;
	}

	float3 newGravity = GetGravityAtParticle(particleId);
	float3 newTension = GetTensionAtPoint(particleId);
	//float3 newNormal = GetBoxNormalForce(particleId);

	acceleration += (/*newNormal +*/ newTension + newGravity)/particleMass;

	return acceleration;
}

#pragma kernel ParticleLoop 
[numthreads(64,1,1)]
void ParticleLoop(uint3 id : SV_DispatchThreadID)
{
	uint currentParticleIdx = id.x;
	if(currentParticleIdx >= nParticles){return;}

	Particle prevParticle = particleRead[currentParticleIdx];
	if(frame == 0)
	{
		prevParticle.velocity = float3(0.0,0.0,0.0);
		prevParticle.position = float3(pcgf(currentParticleIdx), pcgf(currentParticleIdx+7), 0.0);
		prevParticle.density = 1;

		particleRead[currentParticleIdx] = prevParticle;
	} else
	{
		float3 frameAcceleration = CalculateAcceleration(id);
		prevParticle.velocity += timeStep * frameAcceleration;
		prevParticle.position += prevParticle.velocity * timeStep;
	}

	particleWrite[currentParticleIdx] = prevParticle;
	particlePositions[currentParticleIdx] = prevParticle.position;
}

#pragma kernel ParticleDensity
[numthreads(64,1,1)]
void ParticleDensity(uint3 id : SV_DispatchThreadID)
{
	uint currentParticleIdx = id.x;
	if(currentParticleIdx >= nParticles){return;}

	Particle particle = particleRead[currentParticleIdx];

	float density = GetDensityAtParticle(id);

	particle.density = density;

	particleWrite[currentParticleIdx] = particle;
}