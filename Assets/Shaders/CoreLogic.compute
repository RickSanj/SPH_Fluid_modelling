#define PI 3.14159265358979323846

struct Particle
{
    float3 position;
	float3 velocity;
	float3 viscosity;
    float pressure;
    float density;
};

RWStructuredBuffer<Particle> particleRead;
RWStructuredBuffer<Particle> particleWrite;

////To be set from GPU controller

uint nParticles;
float time;
uint frame;
float viscosityCoefficient;
float tensionCoefficient;
float3 gravityVector;
float timestep = 1;
float3 BoxSize;
float particleMass= 2.0;
float radius = 2;

float BOX_SCALE;
float BOX_INFLUENCE;

//////////////////////

//////Util/////
uint pcg(uint v) {
	uint state = v * 747796405u + 2891336453u;
	uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
	return (word >> 22u) ^ word;
  }
  
float pcgf(uint v) {
return float(pcg(v)) / float(0xffffffffu);
}
/////////////

///////Kernels
float WPolyh = 0;

float WPoly(float3 deltaPos, float h){
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefA = 4.0 / (PI*pow(h, 8.0));
		float v = h*h - dst*dst;
		return coefA * pow(v, 3.0);
	}
	return 0;
}

float3 WPolyGradient(float3 deltaPos, float h)
{
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefB = 24.0 / (PI * pow(h, 8.0));
		return -coefB * deltaPos * pow((h*h - dst*dst), 2.0);
	}
	return float3(0.0, 0.0, 0.0);
}

float WPolyLaplace(float3 deltaPos, float h)
{
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefC = 24.0 / (PI * pow(h, 8.0));
		return -coefC * (h*h - dst*dst) * (3*h*h - 7*dst*dst);
	}
	return 0;
}

float WSpikyh = 0;
float3 WSpikyGradient(float3 deltaPos, float h)
{
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefB = 30.0 / (PI * pow(h, 5.0));
		return (-coefB * deltaPos * pow((h - dst), 2.0)) / dst;
	}
	return float3(0.0, 0.0, 0.0);
}

float WVisch = 0;
float WViscLaplace(float3 deltaPos, float h)
{
	float dst = length(deltaPos);
    if (dst > 0 && dst <= h)
	{
		float coefC = 20.0 / (PI * pow(h, 5.0));
		return -coefC * (h - dst);
	}
	return 0;
}
/////////////

///////Forces
float GetDensityAtParticle(uint3 id)
{
	uint currentParticleIdx = id.x;
	float density = 0;
	for(uint i = 0; i < nParticles; i++)
	{
		density += WPoly(particleRead[currentParticleIdx].position - particleRead[i].position, WPolyh);
	}
	return density*particleMass;
}

float3 GetGravityAtParticle(uint3 id)
{
	return particleRead[id.x].density * gravityVector;
}

float3 GetPressureAtParticle(uint3 id)
{
	uint currentParticleIdx = id.x;
	float3 newPressure = float3(0,0,0);
	for(uint i = 0; i < nParticles; i++)
	{
		float tempTerm = ((particleRead[currentParticleIdx].pressure + particleRead[i].pressure)*particleMass) /(2 * particleRead[i].density);
		float3 pressureContribution = WSpikyGradient(particleRead[currentParticleIdx].position - particleRead[i].position, WSpikyh) * tempTerm;

		newPressure += pressureContribution;
	}
	return -1 * newPressure;
}

float3 GetViscosityAtParticle(uint3 id)
{
	uint currentParticleIdx = id.x;
	float3 newViscosity = float3(0,0,0);

	for(uint i = 0; i < nParticles; i++)
	{
		float3 tempTerm = particleRead[i].viscosity - particleRead[currentParticleIdx].viscosity * (particleMass/particleRead[i].density);
		tempTerm *= WViscLaplace(particleRead[currentParticleIdx].position - particleRead[i].position, WVisch);
	}
	return viscosityCoefficient * newViscosity;
}

float3 GetTensionNorm(uint3 id)
{
	uint currentParticleIdx = id.x;
	float3 newNorm = float3(0,0,0);

	for(uint i = 0; i < nParticles; i++)
	{
		float3 normContribution = WPolyGradient(particleRead[currentParticleIdx].position - particleRead[i].position, WPolyh)/particleRead[i].density;
		newNorm += normContribution;
	}
	return -1 * newNorm * particleMass; //theoretically minus must be here
}

float GetTensionLaplacian(uint3 id)
{
	uint currentParticleIdx = id.x;
	float newLaplacian = 0;

	for(uint i = 0; i < nParticles; i++)
	{
		float laplacianContribution = WPolyLaplace(particleRead[currentParticleIdx].position - particleRead[i].position, WPolyh)/particleRead[i].density;
		newLaplacian += laplacianContribution;
	}
	return newLaplacian * particleMass;
}

float3 GetTensionAtPoint(uint3 id)
{
	float3 norm = GetTensionNorm(id);
	return -tensionCoefficient * GetTensionLaplacian(id) * norm / length(norm);
}

float smoothstep(float x, float a, float b) {
    float frac = (x-a)/(b-a);
    float max = frac>0 ? frac : 0;
    float t = max<1 ? max : 1;
   
    return t*t*(3-2*t); 
}

float3 boxNormalForce(float3 curPoint) {
	float _box_start = BOX_SCALE - BOX_INFLUENCE;
    float3 force;
    float horizontal = smoothstep(abs(curPoint.x), _box_start, BOX_SCALE);
    float vertical = smoothstep(abs(curPoint.y), _box_start, BOX_SCALE);
    force.x = -curPoint.x * horizontal;
    force.y = -curPoint.y * vertical;
    
    return force;
}
/////////////
// #pragma kernel Integrate
// [numthreads(64,1,1)]
// void Integrate (uint3 id : SV_DispatchThreadID)
// {
    
//     // v(t + Δt/2) = v(t - Δt/2) + a(t)Δt
//     // x(t + Δt/2) = x(t) + v(t + Δt/2)Δt

//     float3 acceleration = _particles[id.x].currentForce / particleMass;

//   _particles[id.x].velocity = _particles[id.x].velocity + (acceleration * timestep);
//     _particles[id.x].position = _particles[id.x].position + (_particles[id.x].velocity * timestep);

//     float3 topRight = boxSize / 2;
//     float3 bottomLeft = -boxSize / 2;

//      if (_particles[id.x].position.x - radius < bottomLeft.x) {
//         _particles[id.x].position.x = bottomLeft.x + radius;
//     }

//     if (_particles[id.x].position.y - radius < bottomLeft.y) {
//         _particles[id.x].position.y = bottomLeft.y + radius;
//     }

//     if (_particles[id.x].position.z - radius < bottomLeft.z) {
//         _particles[id.x].position.z = bottomLeft.z + radius;
//     }


//     if (_particles[id.x].position.x + radius > topRight.x) {
//         _particles[id.x].position.x = topRight.x - radius;
//     }

//     if (_particles[id.x].position.y + radius > topRight.y) {
//         _particles[id.x].position.y = topRight.y - radius;
//     }

//     if (_particles[id.x].position.z + radius > topRight.z) {
//         _particles[id.x].position.z = topRight.z - radius;
//     }
// }

#pragma kernel Integrate
[numthreads(64,1,1)]
void Integrate (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= nParticles) return;

	Particle currentParticle = particleRead[id.x];
	if(frame == 0)
	{
		currentParticle.velocity = float3(0,0,0);
		currentParticle.pressure = 0;
		currentParticle.density = 0;
		//set random initial positions
		currentParticle.position = float3(pcgf(id.x), pcgf(id.x+1), 0.0);
	} else 
	{
		float3 totalForce = float3(0.0, 0.0, 0.0);
	
		totalForce += GetPressureAtParticle(id);
		totalForce += GetViscosityAtParticle(id);
		totalForce += GetTensionAtPoint(id);
		totalForce += GetGravityAtParticle(id);
	
		float3 acceleration = totalForce / currentParticle.density;
	
		currentParticle.velocity += acceleration * timestep;
		currentParticle.position += currentParticle.velocity * timestep;
		particleWrite[id.x] = currentParticle;
	}
    // float3 boxMin = -BoxSize / 2;
    // float3 boxMax = BoxSize / 2;
    
    // if (currentParticle.position.x <= boxMin.x + radius) {
    //     currentParticle.position.x = boxMin.x + radius;
    //     currentParticle.velocity.x *= -1;
    // }
    // if (currentParticle.position.y <= boxMin.y + radius) {
    //     currentParticle.position.y = boxMin.y + radius;
    //     currentParticle.velocity.y *= -1;
    // }
    // if (currentParticle.position.z <= boxMin.z + radius) {
    //     currentParticle.position.z = boxMin.z + radius;
    //     currentParticle.velocity.z *= -1;
    // }
    // if (currentParticle.position.x >= boxMax.x - radius) {
    //     currentParticle.position.x = boxMax.x - radius;
    //     currentParticle.velocity.x *= -1;
    // }
    // if (currentParticle.position.y >= boxMax.y - radius) {
    //     currentParticle.position.y = boxMax.y - radius;
    //     currentParticle.velocity.y *= -1;
    // }
    // if (currentParticle.position.z >= boxMax.z - radius) {
    //     currentParticle.position.z = boxMax.z - radius;
    //     currentParticle.velocity.z *= -1;
    // }
}

// #pragma kernel InitParticles
// [numthreads(64,1,1)]
// void InitParticles (uint3 id : SV_DispatchThreadID) {
//     if (id.x >= nParticles) return;

//     Particle p;
//     p.position = float3(id.x * 0.1, 0, 0);
//     p.velocity = float3(0.1, 0, 0);
// 	p.viscosity = 1;
// 	p.pressure = 0;
// 	p.density = 0.1;
//     particleWrite[id.x] = p;
// 	// float2 uv = GetUV(id);
// 	// SetParticlePosition(id, MaxwellFlatCircle(uv.x, uv.y, time));
// }